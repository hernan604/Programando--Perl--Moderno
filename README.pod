=encoding utf8

use strict;
use warnings;

=head1 PROGRAMANDO PERL MODERNO - PARA INICIANTES

=head2 AVISO

Este documento ainda está em desenvolvimento.

=head2 RESUMO

O público álvo deste tutorial é principalmente novos programadores da linguagem perl. A intenção é que este manual tenha qualidade suficiente para servir e atrair mais e mais programadores ao fantástico universo da linguagem perl. A intenção inicial do autor é esclarecer dúvidas que o próprio autor gostaria que lhe tivessem sido esclarecidas o quanto antes.

A parte de "Temas Livres" ao final deste documento está aberta para quem quiser contribuir. Deixei alguns temas como exemplo.. a idéia colocar soluções para problemas do dia-a-dia que usuários podem enfrentar e servir como referência para consulta.

Entre em contato, ou submeta um pull request com o fix caso encontre erro neste documento.

Toda ajuda é bem vinda para melhorar este documento.

=cut
#   Ha muito tempo tenho vontade de criar um tutorial para ajudar o pessoal que está aprendendo ou quer aprender mais sobre a linguagem.
#   Então fiz este tutorial para os brasileiros e falantes da lingua portuguesa de plantão interessados em aprender a linguagem de programação perl.
#   A intenção é cobrir temas genéricos e relevantes para programação com perl.
#   Como o assunto não é simples, contribuições de imediato são bem vindas para ajudar a melhorar o material. Adicione seu nome na área de "Colaboradores" caso decida colaborar.
#   A parte mais legal de escrever este tutorial é a oportunidade que tenho de re-ler conceitos através do perldoc

#   A idéia deste tutorial é oferecer um formato de leitura rápida e rápido entendimento para quem está aprendendo.

=head2 Instalação do perl

É imporante ressaltar que algumas máquinas linux, mac e bsd vem com um perl instalado por padrão. Esse perl é utilizado pela máquina para gerenciar N coisas e não é recomendável mexer nele pois sua máquina depende dele assim como suas aplicações. Para não gerar conflito de desinstalações e evitar quebras ou uso de root, recomanda-se a instalação de uma versão local, que fica dentro do diretório do seu usuário. Com essa configuração de perl local é possível instalar módulos sem a necessidade de usuário root. Isso tambem é importante pois separa bem quais usuários executam e tem acesso a quais partes do sistema.

Para verificar se tem perl na máquina, digite:

  $ perl -v

=head3 perlbrew

Primeiro você verifica se tem alguma versão perl já instalada no sistema:

  $ perl -v

Agora sim, instale o perlbrew:

  $ curl -L http://install.perlbrew.pl | bash

  $ source ~/perl5/perlbrew/etc/bashrc

  $ perlbrew available

  $ perlbrew -j 8 install 5.19.1        # use 8 threads para compilar

Essa linha que você executou: 

  $ source ~/perl5/perlbrew/etc/bashrc

precisa ser adicionada no ~/.bash_profile ou ~/.bashrc . Pois ela precisa ser executada sempre antes de usar a versão esperada do perl. É só adicionar no final desses arquivos e depois sair do terminal e abrir ele novamente. Executar o comando perl -v para ter certeza que o perlbrew está sendo executado corretamente e a versão apresentada é a correta que você instalou.

Após finalizar a instalação, altere a versão para a que você instalou:

  $ perlbrew switch 5.19.1

e verifique a versão:

  $ perl -v

Depois instale o cpanm. É com o cpanm que se instala módulos perl.

  $ perlbrew install-cpanm

E para instalar módulos com o cpanm:

  $ cpanm Nome::Modulo1 Modulo2::Etc

=head3 local::lib

O local::lib é uma alternativa ao perlbrew. Bastante utilizada.

  #TODO

=head2 Módulos perl

Uma caracteristíca da linguagem perl é o ecosistema que foi formado ao longo dos anos. Primeiro veio o CPAN onde foi possível compartilhar os módulos. Após isso foram sendo adicionadas mais e mais facilidades e assim foi formado o ecossistema perl que hoje contempla:

  cpan            #repositório oficial
  irc             #salas de bate papo para acesso direto aos desenvolvedores no mundo todo
  documentação    #o cpan tem excelentes documentações junto aos módulos
  testes          #muitas aplicações tem testes. Alem de servir como testes, serve como referência de uso das apps
  request tracker #o request tracker RT do cpan é um produto usado pelas maiores empresas do mundo, incluindo a NASA

=head3 PAUSE

O PAUSE é nome do sistema onde são enviados os módulos. Todos os módulos que entram no CPAN passam pelo PAUSE.

  http://pause.perl.org/

=head3 CPAN - O repositório oficial

O cpan é o repositório oficial no mundo perl. fica em www.cpan.org ou search.cpan.org. Lá você digita o termo e confere os módulos que solucionam essa tarefa.

Você pode digitar "google", "twitter","excel","json" para ter uma listagem de módulos relacionados à busca.

Existe um módulo chamado Task::Kensho que foi criado para servir de referência sobre quais os melhores módulos para determinadas tarefas. O módulo Task::Kensho serve como link para outros módulos que já estão 'reconhecidos' como sendo os mais indicados. O Task::Kensho pode ser encontrado em:

  https://metacpan.org/pod/Task::Kensho

Veja alguns exemplos de modulos no cpan:

  https://metacpan.org/pod/Mango
  https://metacpan.org/pod/Mojolicious::Guides
  https://metacpan.org/pod/release/ETHER/Catalyst-Manual-5.9007/lib/Catalyst/Manual/Tutorial.pod
  https://metacpan.org/pod/release/YANICK/Dancer-1.3120/script/dancer
  https://metacpan.org/pod/Net::Twitter
  https://metacpan.org/pod/WWW::YouTube::Download
  https://metacpan.org/pod/Spreadsheet::WriteExcel

=head3 Documentação

Documentação é levada bem a sério no cpan. Existe alguns padrões mínimos a serem seguidos, por exemplo, todos os módulos perl tem no mínimo os seguintes itens em sua documentação:

  SYNOPSIS      #exemplo rápido de uso
  DESCRIPTION   #descrição detalhada
  AUTHOR        #informações para contactar o autor
  LICENSE       #informações da licensa

Isso é bacana pois ao procurar um módulo, é certo que dá pra ter uma noção do seu uso já na 'synopse'.

Toda a documentação é feita no formato POD ( plain old documentation )

=head3 POD

POD = plain old documentation. é um formato de documentação que pode residir junto aos código fonte perl. E durante a instalação do módulo, é gerada a documentação com base no conteúdo POD nos arquivos do módulo.

Este documento é feito em POD. Existem plugins que lêem POD e transformam em HTML, man pages, etc, diferentes formatos. 

Você pode conferir o POD original deste documento em:

    https://raw2.github.com/hernan604/Programando--Perl--Moderno/master/README.pod

Se você notar, vai ver várias diretivas:

    =head2 Título heading 2
    =head3 Título heading 3

etc... são 'tags' do formato POD.

=head3 Código fonte

É possível baixar e visualizar o código fonte. O link de download indica um arquivo.tar.gz que é o fonte do módulo em si. No entanto tambem é possível visualizar os códigos fonte clicando em 'source', ex:

  https://metacpan.org/source/MMIMS/Net-Twitter-4.01002/lib/Net/Twitter.pm

=head3 Testes

Os testes são levados bastante a sério no desenvolvimento de módulos perl que estão no cpan. São os testes bem feitos que vão garantir que determinado módulo continua funcionando ou quebrou.

A execução de-facto é realizada por pessoas e empresas com cluster de computadores que utilizam um módulo de "framework de smoke test" que agilizam o teste em massa de módulos enviados ao cpan. Isto que dizer que todo módulo que é enviado ao cpan é testado nas mais diversas plataformas (win/linux/bsd/etc) e nas mais diversas versões perl. Assim que um teste é executado, em caso de erro um LOG é enviado por email ao desenvolvedor. É um log igual ao que o desenvolvedor teria se estivesse sentado e executase a aplicação na máquina do teste. Então o LOG pode ser analisado e o problema pode ser corrigido. Feito isso é possível gerar uma nova release e subir novamente ao cpan, e verificar se o problema foi solucionado.

Então isso facilita muito pois você precisa criar os testes, executar e fazer eles passarem na sua máquina. Ao subir o módulo no cpan, os testers tem framework automatizado para testar sua app em outras plataformas, ai você recebe os logs por email em caso de erro, arruma e sobe uma nova versão. Se o problema for em uma versão distinta à que em instalada em sua máquina, você pode usar o perlbrew e instalar a versão que deu pau para tentar simular o erro localmente e encontrar soluções.

Tendo em vista que os framework de testes automatizam para todas as versões de perl e plataformas, isto quer dizer que ao sair uma nova versão do perl, seu módulo é testado automaticamente. E se tiver problemas, será enviado o LOG.

Tudo isso pode ser encontrado através de links dentro de um módulo no cpan e metacpan.

Veja exemplo de matriz de testes, é possível ver a versão perl e plataforma. E, na coluna esquerda é possível ver um resumo da evolução e versão dos módulos.

  http://www.cpantesters.org/distro/N/Net-Twitter.html#Net-Twitter-4.01002?oncpan=1&distmat=1
  http://www.cpantesters.org/distro/M/Mojolicious.html#Mojolicious-4.72?oncpan=1&distmat=1
  http://www.cpantesters.org/distro/D/Dancer.html#Dancer-1.3120?oncpan=1&distmat=1
  http://www.cpantesters.org/distro/S/Spreadsheet-ParseExcel-Simple.html#Spreadsheet-ParseExcel-Simple-1.04?oncpan=1&distmat=1

Existe até um ranking para saber quem testou mais módulos:

    http://stats.cpantesters.org/testers.html

Além de um contador ao vivo:

    http://stats.cpantesters.org/

=head3 Autores dos módulos

No cpan, junto aos módulos é possivel encontrar dados para entrar em contato com o responsável pelo módulo. Normalmente tem email e nome, github, etc.

Se um dia estiver desenvolvendo e precisar de uma customização, suporte ou melhoria em módulo, pode entrar em contato direto e contratar os serviçoes.

=head3 RT - Request Tracker

Todos os autores de módulo tem à disposição o RT, para registrar e solucionar bugs nos módulos.

RT: http://www.bestpractical.com/rt/who.html

=head3 IRC - chat com os desenvolvedores

Existem salas de batepapo em um servidor oficial perl. Para acessar, é necessário conectar no servidor IRC abaixo através dos apps mibbit, mIRC, xchat, irssi, pidgin, entre outros.

  irc.perl.org

Os módulos mais usados tem salas de batepapo bastante ativas com umas 300 pessoas e são discutidas soluções. Tambem rola muita ajudas.

O ponto bacana é a facilidade do contato direto com os criadores dos mais diversos módulos/frameworks e até desenvolvedores da linguagem perl.

=head3 Metacpan

Metacpan é um cpan com cara mais nova. Ele foi criado para ser uma alternativa ao cpan oficial. O metacpan tambem é open source, no entanto este utiliza Elastic::Search para realizar as buscas instantâneas. Outro ponto bacana sobre o metacpan é a possibilidade de forkar o projeto e contribuir com plugins e perfumaria para o site.

=head2 Ajuda

As instalações perl inclúem por padrão o perldoc, que nos ajuda como referência e manual de uso.
Através dele é possível visualizar os manuais de módulos e funções. É similar ao comando "man", e sempre é possível executar um "man Nome::Modulo"

Exemplo para ler os manuais de pragmas internos do perl:

    $ perldoc pragma
    $ perldoc strict
    $ perldoc warnings

Exemplo para ler manual de um módulo:

    $ perldoc Some::Module

Exemplo para ler o manual das funções internas:

    $ perldoc -f sort
    $ perldoc -f qw
    $ perldoc -f push
    $ perldoc -f shift

Embora a leitura seja pesada, tem bastante coisa útil dentro desses manuais. Talvez não tanto para principiantes, mas é sempre bom se acostumar a usar o perldoc como referência na hora de usar um comando, ou, módulo.
E aos poucos o seu uso torna-se natural.

Não menos importante, no irc.perl.org tambem é possível obter ajuda.

=head2 Execução de um script perl

Para executar o script perl , você vai ter que abrir um terminal e ir até o diretório onde se encontra seu script. Caso esteja numa máquina windows, o linux é bastante recomendável pois agiliza bem o desenvolvimento com perl.

O jeito mais direto é assim:

    cd /home/usuario/script/
    perl meu_script.pl

Isso quer dizer que ele vai apenas chamar seu script e executar.

Existem outras opções ótimas para desenvolvedores, que possibilitam usar versões especificas de módulos que o script esteja usando. Ou seja, supondo que 'meu_script.pl' vai usar o módulo Modulo::XYZ, no caso acima seria usada a versão que está instalada junto com minha versão de perl atual.

No entanto eu posso indicar um diretório onde esse módulo está, utilizando o argumento -I../diretorio/modulo/lib (i maiúscilo seguido do diretorio/lib ) assim:

    cd /home/usuario/script
    perl -I/Downloads/Modulo-XYZ/lib/ meu_script.pl

Isso fará o script usar o Modulo::XYZ do diretório indicado: /Downloads/Modulo-XYZ/lib/ ao invés do que está instalado junto com seu perl.

Isso é bastante útil na hora de debugar algum módulo externo. E tambem para usar módulos fazendo apenas o download e indicando o diterório do modulo/lib. Ou seja, não necessariamente precisaria instalar o módulo... eu posso indicar o local do módulo em tempo de execução. Para a aplicação é transparente. Dessa maneira é possível criar um 'bundle' que contém todos as depêndencias necessárias para executar o módulo.

=head2 Variáveis de ambiente

As variáveis de ambiente podem ser acessadas através da variável $ENV{"PATH"}. 

Variáveis de ambiente tambem servem muito bem para salvar usuários e senhas de acesso nos sistemas da rede.

=head2 Escopo de variável

Os escopos estão presos aos {} e às 'sub {}'. Ou seja , blocos de código e métodos. Veja os exemplos de uma linha

    $ perl -e '{my $a = 10; warn $a; } warn $a '
    #saida
    10 at -e line 1.
    Warning: something's wrong at -e line 1.


    $ perl -e ' my $a = 20; { my $a = 10; warn $a; } warn $a '
    #saida
    10 at -e line 1.
    20 at -e line 1.


    $ perl -e ' my $a = 20; { my $a = 10; warn $a; } warn $a; sub { my $a = 30; warn $a; }->() ; warn $a;'
    #saida
    10 at -e line 1.
    20 at -e line 1.
    30 at -e line 1.
    20 at -e line 1.


    $ perl -e ' my $a = 20; { my $a = 10; warn $a; { my $a = 40; warn $a; } warn $a } warn $a '
    #saida
    10 at -e line 1.
    40 at -e line 1.
    10 at -e line 1.
    20 at -e line 1.

=head2 Métodos

Em perl, métodos são chamados 'subrotina' ou 'sub'. perldoc -f sub
Todos os métodos perl são reconhecidos através da definição de subrotina 'sub' ex:

    sub set_nome {
        my ( $nome ) = @_;
    }

Métodos com orientação a objeto recebem o $self como primeiro argumento. $self é a referência para o próprio objeto. É como o this no javascript

    sub set_nome {
        my ( $self, $nome ) = @_;
    }

Os argumentos sempre chegam no @_.
Você não passa o $self, ele é passado automaticamente para você sempre que trabalha com orientação a objetos.
Eu poderia chamar tanto o primeiro quanto o segundo método da segunte maneira:

    $pessoa->set_nome( "Bla" )

e $nome teria valor de "Bla"

Se eu quiser ter mais argumentos posso fazer:

    sub set_coisas {
        my ( $self, $coisa1, $coisa2, $coisa3 ) = @_;
    }

    $pessoa->set_coisas( 'item1', "item2", 3 );
    # $coisa1 = 'item1'
    # $coisa2 = 'item2'
    # $coisa3 = 3

Se eu quiser posso executar uma sub anonima:

    sub { my ( $arg1, $arg2 ) = @_; .......  }->( "Argumento1", "Coisa2" )

ou, atribuir a subrotina em uma variável e executar ela depois, ex:

    my $pular = sub { warn "pular" };
    $pular->();

Passando métodos como argumentos:

    my $callback_send_msg = sub {
        my ( $msg ) = @_;
        warn $msg
    };

e uma chamada de um objeto '$item' co método faca_algo

    $item->faca_algo( "arg1", "arg2", $callback_send_msg );

    and then inside the 'faca_algo' method:

    sub faca_algo {
        my ( $arg1, $arg2, $callback ) = @_;
        ...
        $callback->( "Código executado com sucesso." );
    }

=head3 Métodos anônimos

Tambem é possível trabalhar com métodos/funções anônimas em perl. É possível passar métodos ou a referência deles como callback.

Função anônima, posso simplesmente criar um método anônimo que recebe 2 argumentos e já é executado: 

  perl -e 'sub { my ( $arg1, $arg2 ) = @_;  warn $arg1.$arg2 }->( "argumento1", "argumento2" ); '

Ou eu posso criar essa closure anônima ( perldoc -f sub ) e receber a referência do método. podendo usar a variável como se fosse um método.

  perl -e 'my $metodo = sub { my ( $arg1, $arg2 ) = @_;  warn $arg1.$arg2 };  warn "---"; $metodo->( "argumento1", "argumento2" ); '

Callbacks, tambem é possível. É só passar a referência do método como argumento de outro método. Trivial.

  perl -e ' my $callback = sub { my ( $msg ) = @_; warn $msg  }  ; sub {  my ( $cb ) = @_; $cb->( "here callback" ) }->( $callback )  '

=head2 Variáveis

Por padrão todas as variáveis começam com $ e devem ser declaradas com 'my'. ex:

    my $variavel    = "algo";
    my $var2        = 1;
    my $array       = [ 1,2,3,"quatro" ];
    my $carro       = Carro->new();
    my @list        = ("aa","bb",1,2,3);
    my %hash        = (nome=>"jão",idade=>"dimenor");

=head3 Tipos de variáveis / Estrutura de dados:

    my $var         = [1, 2, 3];                                # ARRAY
    my $pessoa      = { nome => 'jão', idade => 'dimenor' };    # HASH
    my $var         = Some::Module->new();                      # referencia a objeto
    my @list        = ("nome","jão");                           # lista, c/ 2 itens
    my %hash        = @list;                                    # lista em contexto associativo, ex: nome => jão

=head2 scalar

  $ perldoc perldata

Variáveis scalares podem ser números, strings ou referências para outras variáveis. A variável escalar é sempre uma única coisa e pode ser passada como argumento como uma única coisa.

Uma variável scalar sempre começa com $, ex:

    $texto = ""

=head3 array e listas

Arrays e listas são muito parecidos e podem funcionar em conjunto, mas não são exatamente a mesma coisa.

array é scalar (scalar é o $ cifrão ou sigíl): # e scalar é apenas uma coisa. neste caso é uma referência para um objeto do tipo ARRAY

    $meu_array = [
        "coisa1",
        "coisa2"
    ]

lista (lista é o @ arroba):

    @minha_lista = (
        "coisa1",
        "coisa2"
    );

Dica, para não ter que ficar digitando aspas duplas toda hora, existe uma opção chamada "qw" que coloca os as aspas automaticamente. Mas só funciona para palavras sem 'traço' ou espaços. ex:

    @lista = (  qw|item1 item2 item3|  );    #é a mesma coisa que @lista = ( 'item1', 'item2', 'item3' );

Lembre-se, um scalar é sempre uma coisa apenas. E a lista pode ser mais de uma coisa.

Então por exemplo, se eu chamar um método e passar minha lista para esse método, o que acontece ?

    my @l=(qw|aa bb cc|);   #LISTA
    my $test = sub {                            # sub é tipo function no javascript. é declaração de método. neste caso joguei o método na variável $test
        my ( $um, $dois, $tres ) = @_ ;
        warn $um;
        warn $dois;
        warn $tres;
    } ;
    $test->( @l ); # chamada passando a lista

saida: cada item da lista caiu como um argumento.

    aa at -e line 1.
    bb at -e line 1.
    cc at -e line 1.

Agora, ao invés de passar a lista, vou passar um array

    my $l=[qw|aa bb cc|];     #ARRAY
    my $test = sub {
    my ( $um, $dois, $tres ) = @_ ;
        warn $um;
        warn $dois;
        warn $tres;
    } ;
    $test->( $l );

    #saída
    ARRAY(0x94d4068) at -e line 1.           # recebeu o array no primeiro argumento, pois array é apenas uma coisa.
    Warning: something's wrong at -e line 1. # não recebeu nada no segundo argumento
    Warning: something's wrong at -e line 1. # não recebeu nada no terceiro argumento

* observe tambem o argumentos: my ($um,$dois,$tres) .. eles tambem são uma lista. Ou seja, my (...) = @_; assim como @lista = (...);

Para saber o tamanho de uma lista:

    my @lista = ( 1,2,3 );
    my $tamanho = @lista;
    warn $tamanho; #3

    ou $tamanho = scalar @lista; # nem sempre é obrigatório o uso de parentêsis
                                 # na chamada dos comandos. Poderia ter chamado
                                 # assim: $tam = scalar( @lista ); c/parentesis
    ou $tamanho = $#lista;

e para arrays:

    my $lista = [ 1,2,3 ];
    length $lista; #3

Acesso aos valores da lista:
    
    my $item    = $minha_lista[2]         #terceiro item da lista
    $minha_lista[2] = "bla"               #altera terceiro valor

Foreach loop em lista:

    my @lista = qw(|aa bb cc|);
    foreach my $item ( @lista ) {
        warn $item;
    }

Foreach loop em array. Para fazer um loop em um array, é necessário de-referenciar o array em lista, pois o foreach exige uma lista como argumento para trabalhar.

    $ perldoc perlsyn #procure por foreach, while etc.

    my $arr = [ qw|  aa bb cc | ];
    foreach my $item ( @{  $arr  } ) {
        warn $item;
    }

For com lista:

    my @l=(qw|aa bb cc|); 
    for ( my $i =0; $i < @l; $i++ ) { 
        warn $l[ $i ] ;
    } 

For com array:

    my $l=[qw|aa bb cc|]; 
    for ( my $i =0; $i < @{$l}; $i++ ) { 
        warn $l->[$i];    #opcao 1 para printar o valor
        warn @{$l}[$i] ;  #opção 2 para printar o valor
    }

While com lista:

Tendo em vista que o while espera uma expressão, ele só vai executar se essa expressão resultar positiva. 
Vou usar o comando shift que retira e retorna o primeiro item da lista, reduzindo a lista em menos 1 item. E quando terminar de retornar os valores, a expressão vai resultar negativo e o while não será executado.

    my @lista = (qw| aa bb cc| ); 
    while ( my $item = shift @lista) { 
        warn $item        # <-- todos os comando precisam obrigatoriamente de ponto e vírgula, menos o último comando do bloco.
    }

Map, o map permite trabalhar com cada item da lista. É igual ao foreach, mas ele pode ser encadeado com outros maps ou greps pois ambos esperam uma lista como entrada e ambos retornam uma lista como resultado.

    my @pessoas = (
        {
            nome  => 'Jão',
            idade => 'dimenor',
            ensino=> 'médio',
        },
        {
            nome  => 'Mary',
            idade => 21,
            ensino=> 'superior',
        },
        {
            nome  => 'Janet',
            sobrenome=>'Silva',
            idade => 25,
            ensino=> 'superior',
        },
    );

    @pessoas = map {
        if ( ! $_->{ sobrenome } ) {
            $_->{ sobrenome }  = undefined;
            $_->{ status }     = "SEM-SOBRENOME" ;
        }
        $_; # valor que será retornado. Não precisa colocar o 'return'
        # return $_; #outra opção seria colocar o return, mas não é obrigatório
    } @pessoas;
    use DDP; warn p @pessoas;

grep, posso usar o grep  para filtrar os maiores de idade dentro de uma lista de pessoas. Esta é uma lista de hashes onde cada hash representa uma pessoa. Usarei o grep para filtrar e obter todas as pessoas que não são dimenor.

    my @pessoas = (
        {
            nome  => 'Jão',
            idade => 'dimenor',
            ensino=> 'médio',
        },
        {
            nome  => 'Mary',
            idade => 21,
            ensino=> 'superior',
        },
        {
            nome  => 'Janet',
            idade => 25,
            ensino=> 'superior',
        },
    );

    my @maior_de_idade = grep {  $_->{ idade }  ne 'dimenor' } @pessoas;
    use DDP; warn p @maior_de_idade;

=head3 Referenciando e De-referenciando

Resumo: para passar a referência normalmente usa-se a \ antes da variável.  E para de-referenciar, usa-se o tipo{}, @{ $var } para de-referenciar $var em lista e %{ $var } para de-referenciar $var em lista-ordenada. É possível referenciar e dereferenciar a la vontê.

Sempre que o código tiver uma lista e precisar passar pra uma função que espera um array, é necessário passar a referência da lista que vira array para o método. É possível passar a lista, mas provavelmente não é isso que você precisa.

    my @lista                         = ( qw| aa bb cc | );
    use DDP; warn p @lista;
    my $lista_array_ref               = \@lista;    #\ retorna a referência
    use DDP; warn p $lista_array_ref; warn ref $lista_array_ref;
    my @lista_dereferenciada          = @{  $lista_array_ref  };
    use DDP; warn p @lista_dereferenciada;

Agora com lista ordenada:

    my %formulario = (
        nome    => 'Jão',
        idade   => 'dimenor'
    );
    use DDP; warn p %formulario;
    my $form       = \%formulario;
    warn p $form; warn ref $form;
    my %form_dereferenciado = %{  $form  };
    warn p %form_dereferenciado;

De-referenciar quer dizer: mudar o contexto dos dados. Ou seja, eu posso ter uma função que aguarda um array como argumento... mas, eu tenho uma lista de valores e preciso passar essa lista pra função que espera um array. Nesse momento eu posso transformar a lista em array para passar pra função.

    my @lista = ( qw| aa bb cc dd ee ff| );
    my $funcao = sub {
        my ( $arr ) = @_;     #recebe um scalar
        use DDP; warn p $arr;
    };

    $funcao->(  \@lista  );   #

Ao passar uma lista por referencia ela é transformada em ARRAY(scalar) para ser recebida apenas como 1 único argumento. E para transformá-la em lista novamente é necessário fazer uma de-referencia.. que funciona da seguinte maneira:

    my @lista = ( qw| item1 item2 item3 | );
    $algo->passar( \@lista, "outra coisa" ); #passou @lista por referencia

e por sua vez o método passar recebe:

    sub passar {
        my ( $lista, $outra_coisa ) = @_;
        use DDP;
        warn p $lista;
        warn ref $lista;            #ARRAY
        my @lista = @{  $lista  };  # Aqui é feita a de-referência de scalar array para lista
        warn p @lista;
    }

E, se tentar fazer:

    warn ref @lista;

vai dar erro pois @lista são várias coisas. assim como %hash; Enquanto variáveis scalares são apenas uma única coisa.

=head3 hash e lista associativa

Hashes tambem podem ser definidos com scalares ou listas ordenadas.

hash scalar:

    my $item = {
        nome    => "jão",
        idade   => "dimenor"
    };

hash com lista ordenada:

    my %item = (
        nome    => "jão",
        idade   => "dimenor"
    );

Para transformar um %item em $item, é só passar a referencia (\). Ou seja,

    $ perl -e 'use strict; use warnings; my %x=(aa=>1,bb=>2); my $h = \%x; use DDP; warn p $h ; warn ref $h; '

Assim que se passa um hash por referência. Ou seja, se vc tem um %algo e precisa passar para um método, você terá que passar a referência disso: \%algo e na outra ponta vai chegar como scalar: $algo e esse scalar vai ser do tipo HASH. Que pode ser verificado através do comando: warn ref $algo.

Para introspectar e visualizar o hash:

    use DDP;
    warn p $item;
    wran p %item;

=head3 lista, lista associativa, arrays e hashes

A lista é representada por uma variávei inicializando com "@". Uma lista são items dentro de parentesis, separados por virgula. Ex.

    my @lista = (
        "nome",
        "jão",
        "idade",
        "dimentor"
    );

Uma lista associativa, apenas altera o entendimento da lista e a transforma em algo parecido com um hash. Ou seja, se eu alterar a lista acima para uma lista associativa, terei o resultado:

    my %lista_associativa = (
        "nome"  => "jão",
        "idade" => "dimentor"
    );

Ou seja, associou os itens impares com os itens pares.

Tambem é possível alterar entre uma ou outra, a diferença delas esta nos @ e %. Logo é possível fazer:

    my %lista = @lista; #e vice versa

O % e @ vai alterar o comportamento se é aplicada lista ou array associativo. No final eles são bem similares e mudam de acorco com % ou @.

=head3 Condição para adicionar ou não item em lista, hash e array

Algo muito bacana pode ser usado em perl, que é colocar um ternário como um item de uma lista, hash ou array.


    use DDP;

primeiro um arrau com um item que é uma lista vazia

    my $array = [
      'um', 
      'dois', 
      (),       # este valor é igual a array em branco, que é igual a nada neste caso.
                # pois () é sempre uma lista de itens, então aqui é uma lista de itens
                # vazia neste caso.. consequentemente acaba não contando como item nenhum.
      'tres'
    ];

    warn p $array;
    warn 'Total de itens: ' .scalar @$array;
    #   \ [
    #       [0] "um",
    #       [1] "dois",
    #       [2] "tres"
    #   ] at t.pl line 10.
    #   Total de itens: 3 at t.pl line 11.

agora um array que tem uma condição para decidir o valor do terceiro item

    my $array2 = [
      'um', 
      'dois', 
      ( 1 == 1 ) 
      ? ( 'sim' ) 
      : ( 'não' ),       # este valor é igual a array em branco, que é igual a nada neste caso.
      'tres'
    ];
    warn p $array2;
    warn 'Total de itens: '. scalar @$array2;
    #   \ [
    #       [0] "um",
    #       [1] "dois",
    #       [2] "sim",
    #       [3] "tres"
    #   ] at t.pl line 22.
    #   Total de itens: 4 at t.pl line 23.

agora, um outro array com condição e retorna 3 itens sim caso a condição seja positiva

    my $array3 = [
      'um', 
      'dois', 
      ( 1 == 1 ) 
      ? ( 'sim', 'sim', 'sim' ) 
      : ( 'não' ),       # este valor é igual a array em branco, que é igual a nada neste caso.
      'tres'
    ];
    warn p $array3;
    warn 'Total de itens: '. scalar @$array3;
    #   \ [
    #       [0] "um",
    #       [1] "dois",
    #       [2] "sim",
    #       [3] "sim",
    #       [4] "sim",
    #       [5] "tres"
    #   ] at t.pl line 35.
    #   Total de itens: 6 at t.pl line 36.

um a lista com condição para decidir qual item entra na lista

    my @list = (
      'um',
      'dois',
      ( 3 == 3 ) ? ( 'tres' ): ( 'inválido' ),
      'quatro',
    );
    warn p @list;
    warn 'Total de itens: ' . scalar @list;
    #   [
    #       [0] "um",
    #       [1] "dois",
    #       [2] "tres",
    #       [3] "quatro"
    #   ] at t.pl line 47.
    #   Total de itens: 4 at t.pl line 48.

Tambem é possível usar o () para setar valor nenhum:

    my @list = (
      'um',
      'dois',
      ( 3 == 3 ) ? ( ): ( ),
      'quatro',
    );
    warn p @list;
    warn 'Total de itens: ' . scalar @list;
    #   [
    #       [0] "um",
    #       [1] "dois",
    #       [2] "quatro"
    #   ] at t.pl line 9.
    #   Total de itens: 3 at t.pl line 10.

ou setar vários itens de uma só vez

    my @list2 = (
      'um',
      'dois',
      ( 3 == 3 ) ? ( 'tres1', 'tres2', 'tres3' ): ( 'inválido' ),
      'quatro',
    );
    warn p @list2;
    warn 'Total de itens: ' . scalar @list2;
    #   [
    #       [0] "um",
    #       [1] "dois",
    #       [2] "tres1",
    #       [3] "tres2",
    #       [4] "tres3",
    #       [5] "quatro"
    #   ] at t.pl line 56.
    #   Total de itens: 6 at t.pl line 57.

agora uma lista ordenada

    my $idade = 17;
    my %lista_ordenada = (
      nome => 'João',
      ( $idade < 18 )
      ? ( idade => 'dimenor' )
      : ( idade => 'dimaior' )
    );
    warn p %lista_ordenada;
    #   {
    #       idade   "dimenor",
    #       nome    "João"
    #   } at t.pl line 67.

um hash

    my $hash = {
        nome => "jão",
        ( $idade  < 18  ) 
        ? ( idade => 'dimenor' ) 
        : ( idade => 'dimaior' ),
    };
    warn p $hash;
    #   \ {
    #       idade   "dimenor",
    #       nome    "jão"
    #   } at t.pl line 119.
    

=head3 Curiosidades

Tambem é possível transformar os resultados da segunte maneira:

    #primeiro vou criar uma lista 
    my     @palavras  = ( qw| nome primeiro sobrenome segundo idade terceiro| );
    warn p @palavras;
    #   [
    #       [0] "nome",
    #       [1] "primeiro",
    #       [2] "sobrenome",
    #       [3] "segundo",
    #       [4] "idade",
    #       [5] "terceiro"
    #   ] at t.pl line 4.

    # agora vou transformar essa lista em uma lista ordenada
    my     %form      = %{{@palavras}};
    warn p %form;
    #   {
    #       idade       "terceiro",
    #       nome        "primeiro",
    #       sobrenome   "segundo"
    #   } at t.pl line 8.

    # agora vou transformar a lista ordenada de volta em lista
    my @lista2 = %form;
    warn p @lista2;
    #   [
    #       [0] "nome",
    #       [1] "primeiro",
    #       [2] "sobrenome",
    #       [3] "segundo",
    #       [4] "idade",
    #       [5] "terceiro"
    #   ] at t.pl line 12.

    my $form_hash = { map { $_ } @lista2 };
    warn p $form_hash;
    #   \ {
    #       idade       "terceiro",
    #       nome        "primeiro",
    #       sobrenome   "segundo"
    #   } at t.pl line 16.

    my $form_hash = {@lista2};
    warn p $form_hash;
    #   \ {
    #       idade       "terceiro",
    #       nome        "primeiro",
    #       sobrenome   "segundo"
    #   } at t.pl line 16.

    # retransforma em lista
    my @lista_3 = %{ $form_hash };
    warn p @lista_3;
    #   [
    #       [0] "idade",
    #       [1] "terceiro",
    #       [2] "sobrenome",
    #       [3] "segundo",
    #       [4] "nome",
    #       [5] "primeiro"
    #   ] at t.pl line 20.

=head3 coma e Fat-coma, virgula e virgula gorda

Existe a virgula e a virgula-gorda. Ambas são a mesma coisa, só muda para representação visual.

Vírgula / Coma

    ,

Vírgula-Gorda / Fat-coma

    =>

Se eu escrever uma lista com => ou , vai dar na mesma... mas => é bastante utilizado em hashes para indicar uma 'associação'

Ou seja,

    my @lista = ( 1, 2, 3 )

é a mesma coisa que

    my @lista = ( 1 => 2 => 3 );

para fazer a prova é possível usar o Data::Printer, que permite printar o objeto na tela. ( introspection )

    my @lista = ( 1, 2, 3 );     use DDP; warn p @lista;
    my @lista = ( 1 => 2 => 3 ); use DDP; warn p @lista;

=head2 Regex - Expressão Regular

A linguagem perl é muito talentosa para trabalhar com textos. Por esse motivo seu engine de regex é o mais avançado entre as linguagens, e virou referência que serve como padrão de compatibilidade. O termo para isso é: PCRE ( Perl Compatible Regular Expressions ). Toda linguagem que implementa um engine de regex bom tem que ser PCRE.

    $ perldoc perlre

O operador de expressão regular em perl:

    =~

e o negador (não match)

    !~

É utilizado da seguinte maneira:

    my $texto = "bla aa bb cc dd aa";
    $texto =~ m/aa/gi;                  #m=match
    $texto =~ s/isto/por aquili/gi      #s=substituição
                                        gi são os modificadores, i é case insensitive
                                        e g=global do começo ao final da string

    $texto =~ m/(.+)algo(?<nome_do_grupo>.+)/g   #um grupo não nomeado e um grupo nomeado

    print $+{nome_do_grupo}

    if ( $text =~ m!bla! ) {
        ...
    }

é possível usar exclamação, barras, colchetes na regex, ex, todas estas representam a mesma coisa:

    m//g m!!g m{}g

    s///g s!!!g s{}{}g

Tem tudo no perlre.

=head3 Matches

As regex retornam por padrão uma lista de matches. Então eu posso fazer algo assim:

    my   $texto = "Jão dimenor";
    my ( $nome, $idade ) = $texto =~ m/(.+) (.+)/ig; # automaticamente $nome recebe o valor do primeiro grupo de matches e $idade recebe o valor do segundo match
    warn $nome;
    warn $idade;

    my   $total = ( $nome, $idade ) = $texto =~ m/(.+) (.+)/ig; # automaticamente $nome recebe o valor do primeiro grupo de matches e $idade recebe o valor do segundo match
    warn $total;

    my   $total =()= $texto =~ m/(.+) (.+)/ig; # automaticamente $nome recebe o valor do primeiro grupo de matches e $idade recebe o valor do segundo match
    warn $total;

=head3 Quantidade de matches

Para saber a quantidade de matches de uma regex, é necessário usar o operador goatse " =()= ". 

Para contar o total de vezes que aparece o trecho aa no texto abaixo:

    my   $texto = "aa bb cc aa aa aa bb aa cc dd aa";
    my   $total_de_aa =()= $texto =~ m!aa!g;
    warn $total_de_aa;

=head3 Transliteração

Para substituir uma letra por outra, usa-se bastante transliteração. As vezes o pessoal faz com regex, ou sei la como, mas o jeito mais coerente é usar transliteração, ex:

Vamos supor que quero transformar todas as vogais em letras maiúscilas. Posso fazer da seguinte maneira com transliteração:

    my $text = "aa bb cc dd ee ff gg";
    $text =~ tr/[aeiou]/[AEIOU]/;
    warn $text;
    #saida: AA bb cc dd EE ff gg

outro uso bem comum é para trocar caracteres acentuados por caracteres sem acento:

    my $text2 = "aaá eée iíí çc";
    $text2 =~ tr!áãíçé!aaice!;
    warn $text2;
    #saída: aaa eee iii cc

=head2 Pragmas

Um pragma é um módulo que influencia sob alguns aspectos na hora de compilar e executar códigos perl.
Dois pragmas muito importantes e bastante usados são o "strict e "warnings".
Isso quer dizer que todos as apps e scripts perl devem começar com:

    use strict;
    use warnings;

Para saber mais sobre pragmas, acesse o perldoc pragma

    $ perldoc pragma

No caso do pragma strict, verifica e valida se todas as variáveis foram declaradas. Caso alguma não tenha sido declarada, imprime um erro com o aviso na tela, ex:
$ perl -e 'use strict; $var = "bla";'
Global symbol "$var" requires explicit package name at -e line 1.
Execution of -e aborted due to compilation errors.

=head3 use strict

Previne uso de variáveis não declaradas.

    $ perldoc strict

=head3 use warnings

Pragma para controlar warnings opcionais

    $ perldoc warnings

Os pragmas funcionam e conseguem modificar apenas dentro do escopo onde foram declarados.

=head2 Instalação de modulos

A instalação de módulos é bastante simples. Com o nome de módulo em mãos, é possível instalar com o comando:

    $ cpanm Nome::do::Modulo Nome::de::Outro::Modulo

O cpanm é o instalador de módulos mais indicado hoje em dia. É super simples e fácil de usar e instalar.

Se houver erro durante a instalação, será apresentado um log junto à mensagem de erro. É importante ler este log, principalmente no final, e localizar a parte onde ocorreu o erro. As vezes um módulo pode ter como pré-requisito/dependência uma lib no sistema.

Por exemplo, para trabalhar com imagens, é sempre bom instalar as libs:

    $ sudo apt-get install libpng-dev libgif-dev libjpeg-dev

Para trabalhar com módulos xml, xpath

    $ sudo apt-get install libexpat-dev

Etc, se na instalação de alguma app for solicitado essas libs antes de serem instaladas, haverá um erro. Tudo estará escrito nos logs.

Já as dependências de módulos, essa é automaticamente gerenciada para você. Cada módulo traz consigo uma lista de dependências, e ao instalar uma, as dependência são instaladas recursivamente automaticamente.

Todos os módulos perl vem com testes, e alguns módulos mais usados as vezes tem muitos muitos testes. Testar tudo pode demorar um pouquinho. Os apressados podem usar a opção

    cpanm --notest  Nome::Modulo  #só use isto se tiver certeza que usa máquina já tem os pre-requisitos instalados

Outra opção é forçar uma instalação que tenha falha durante a execução dos testes.

    cpanm --force   Nome::Modulo

=head3 cpanm

O cpanm é um instalador de módulos. Ele pode instalar módulos do cpan, ou a partir de arquivos locais, ou de qualquer url, entre outras opções avançadas. O mais comum é usar o comando para instalar um módulo do cpanm com o comando cpanm

O cpanm se identifica como sendo a versão mini da app cpan (instalador padrão de módulos). Mini no sentido de ter pouco código e opções mais refinadas.

    $ cpanm Modulo::Bla

Para ver todas as opções

    $ cpanm --help

=head3 cpan

O cpan é a interface oficial para interagir com o cpan. O cpan existe faz mais de 20 anos e através dela é possível instalar módulos. A primeira vez que é executado, a app pede algumas configurações. Uma das opções aceita a resposta padrão para tudo, recomendo. Feito isso é só instalar os módulos da seguinte maneira:

    $ cpan Modulo::Um Modulo::Dois

=head2 Criação de módulos

Existem algumas ferramentas que auxiliam a criação de esqueleto de módulos. Ao mesmo tempo estas ferramentas se mantem atualizadas e criam o esqueleto seguindo os padrões corretos para a criação de um módulo perl.

Um módulo perl, inclúi os arquivos fonte relacionados ao módulo, esses arquivos podem estar listados em um arquivo chamado MANIFEST. Informações sobre dependência são essenciais pois ao subir um módulo no cpan, o robozinho do smoke-tester vai tentar rodar os testes da app e vai dar erro de dependência se ela não tiver sido listada como pré-requisito. A documentação é bastante importante, siga os outros módulos... e a documentação é feita no formato pod.

    $ perldoc pod

Os testes são essenciais e ficam dentro do diretório t/ da applicação.

O nome do módulo tem que ser auto informativo. Não crie nomes estranhos nada a ver. Pesquise outros módulos para se familiarizar com as nomenclaturas. Peça ajuda no irc, ou entre para uma lista de perl mongers no brasil.

Pesquise se já existe um módulo que faz o que o projeto precisa. Provavelmente já existe um módulo que faz o trabalho que já foi amplamente testado.

=head3 Dist::Milla

O Dist::Milla é um gerador de esqueleto de módulos perl. Com ele é possível gerar um módulo em branco e seus arquivos base.

Após instalar o Dist::Milla ( cpanm Dist::Milla ) , execute o setup:

    $ milla setup

depois é só criar módulos com o comando:

    $ milla new Nome::Do::Modulo

    $ milla help

Existem outros geradores de esqueleto.

=head2 Execução de scripts

=head3 one-liners

One-liners são executados através da linha de comando. E tem apenas uma linha. Para executar um trecho de código diretamente na linha de comando, é só jogar o código dentro do comando: perl -e '...codigo...' ex:

    perl -e ' use strict; use warnings; my $var = 10; warn $var+1; '

=head4 Executando aplicações com versões específicas de módulos

Quando um script/app é executado, este provavelmente tem dependências que precisam estar instaladas para rodar um mero: "perl script.pl". No entanto, é possível executar um script sem ter instalado os módulos necessários para execução. É claro que o módulo tem que estar presente, mas ele pode estar presente dentro de qualquer diretório. É necessário apenas passar esse diretório como um argumento na hora de executar o script/app perl.

Esta facilidade é muito boa para aplicações em produção, pois é possível manter repositórios em sincronia e apenas gracefully restartar os serviços indicando o local onde estáo os fontes das dependências do scrpit. Suponha que meu_modulo.pl requer o Meu::Modulo. Mas eu ainda não subi Meu::Modulo para o cpan, e tambem não tenho ele instalado. Meu::Modulo está num diretório local na minha máquina. Então eu executaria o meu_modulo.pl passando o local onde estão os fontes requeridos para a execução, da seguinte maneira:

    perl -I../Meu-Modulo/lib/ -I../Outro-Modulo/lib meu_modulo.pl

Para desenvolvimento tambem é interessante usar módulos dessa maneira, caso contrário seria necessário re-instalar os módulos após cada alteração. Isso seria non-sense.

=head2 print vs warn vs say

    $ perldoc -f warn
    $ perldoc -f print
    $ perldoc -f say

Para imprimir mensagens existe basicamente 3 alteranativas. As mais comuns e tambem mais antigas são print e warn. O say exige declaração do uso da feature say.

As 3 servem para printar mensagens na tela, no entanto, o warn printa em STDERR enquanto print e say printam para STDOUT.

ps. em unix as aplicações podem receber dados do STDIN (ex teclado) e enviar dados para STDOUT (ex terminal) e STDERR ( ex terminal tambem, mas como erro) mais em: http://en.wikipedia.org/wiki/Standard_streams

Print e say, tentando capturar de STDERR ( 2> ), não vai dar certo pois por padrão essas funções mandam pra STDOUT ( > ):

    $ rm log; perl -e 'use feature "say" ; warn "a" ;   ' 2> log && echo "cat log:" && cat log   # usa 2> pra capturar STDERR
    $ rm log; perl -e 'use feature "say" ; warn "a" ;   ' 2> log && echo "cat log:" && cat log   # usa 2> pra capturar STDERR

agora sim, vai conseguir capturar de STDOUT:

    $ rm log; perl -e 'use feature "say" ;  say "a" ;   '  > log && echo "cat log:" && cat log   # usa > pra capturar STDOUT
    $ rm log; perl -e '                   print "a" ;   '  > log && echo "cat log:" && cat log   # usa > pra capturar STDOUT

O warn joga a saída pra STDERR

    $ rm log; perl -e 'use feature 'say' ; warn "a" ;   ' 2> log && echo "cat log:" && cat log   # usa 2> pra capturar STDERR

se tentar capturar a saída do warn na STDOUT, não vai conseguir pois o warn sempre joga pra STDERR

    $ rm log; perl -e 'use feature 'say' ; warn "a" ;   '  > log && echo "cat log:" && cat log   # printa em branco 

tambem é possível forçar o print pra imprimir em STDERR:

    $ print STDERR "texto";     # e pode ser capturado com 2> 
    $ print STDOUT "texto";     # e pode ser capturado com >

=head2 Introspecção/Inspeção de objectos:

A introspecção de objetos é algo essencial para poder debugar e entender o que se passa nas aplicações. Outras vezes ajuda para inspecionar um objeto e lembrar o nome daquele método.

Existem ferramentas bacaninhas para fazer esse tipo de análise, vou listar três bastante utilizadas. Eu uso mais o Data::Printer. Funciona muito bem e foi criada por um conterrâneo brazileiro. O Data::Printer aceita cores e customizações que possibilitam aumentar ou restringir o quê imprimir de um objeto na hora da inspeção. Mostra os métodos publicos e privados, isso é bem útil durante o uso de um módulo.

O uso é simples, no meio do código você mete um warn para printar alguma variável, ex:

    .... codigo ....
        my $item = Some::Thing::Nice->new();
        use DDP; warn p $item;
    .... codigo ....

Vou mostrar exemplos com objetos simples, tipo hash no entanto estes Dumpers podem ser usados em objetos de verdade.

=head3 Data::Dumper

O Data::Dumper vem instalado por padrão junto com o perl.

    perl -e 'my $var={ a=>[1,2,3],x=>1, y=>2, z=>"bla"}; use Data::Dumper; print Dumper( $var );'
    $VAR1 = {
              'y' => 2,
              'z' => 'bla',
              'x' => 1,
              'a' => [
                       1,
                       2,
                       3
                     ]
            };

=head3 Data::Dump::Streamer

    perl -e 'my $var={ a=>[1,2,3],x=>1, y=>2, z=>"bla"}; use Data::Dump::Streamer; print Dump( $var );'
    $HASH1 = {
               a => [
                      1,
                      2,
                      3
                    ],
               x => 1,
               y => 2,
               z => 'bla'
             };

=head3 Data::Printer

    perl -e 'my $var={ a=>[1,2,3],x=>1, y=>2, z=>"bla"}; use DDP; print p $var ;'
    \ {
        a   [
            [0] 1,
            [1] 2,
            [2] 3
        ],
        x   1,
        y   2,
        z   "bla"


=head2 Arquivos

Para trabalhar com arquivos em perl, é necessário abrir um arquivo, e obter seu conteúdo.

O conteúdo pode ser obtido de muitas maneiras e depende de caso a caso. Por exemplo, se estiver trabalhando com arquivos de log que tem 1 terabyte não será possível abrir o arquivo todo de uma vez em memória. Nesse caso, é necessário ler o arquivo de X em X bytes até chegar no final, ou seja em chunks. As vezes interessa fazer um loop nas linhas do arquivo. Emfim, cada caso é um caso.

=head3 Printar todas as linhas de um arquivo

    open
    open( FH , "<" , "README.pod" ) ; while( <FH> ) { print $_ ; print "----------\n"; }  

=head3 Printar determinado número de bytes de arquvio

Esta opção é muito útil para trabalhar com arquivos gigantes que não podem ser abertos de uma única vez pois não cabem na memória da máquina. 

Então é possível fazer open em um arquivo e gerar um filehandle. Posteriormente pode ser executado o comando read para ler N bytes do filehandle.

    open( FH , "<" , "README.pod" ) ;
    my $bytes = 10;
    my $text; while ( read( FH, $text, $bytes ) ) {
        use DDP;
        warn p $text;
    }

Outra opção é mexer com a variável especial $/ ( perldoc perlvar ). O exemplo a seguir utiliza-se desta técnica para alterar o $/ por espaços. Agora quando fizer loop no filehandle, vai printar palavras separadas por espaço.

    open( FH , "<" , "README.pod" ) ; {
        local $/=" " ;      # enable "slurp" mode, altera o padrào ed "\n" para espaço.
        while ( <FH> ) {
            warn $_;
        }
    };

=head3 File::Slurp

Este módulo é fantastico para trabalhar com arquivos. Além deste módulo ser muito bem recomendado, tem padrões excelentes para abrir e escrever arquivos.

    use File::Slurp;
    my $text = read_file( "texto.txt" );
    my @linas = read_file( "texto.txt" );

Veja as demais opções na documentação:

    $ perldoc File::Slurp

=head2 Construção de classes / objetos

    $ perldoc perlootut
    $ perldoc perlobj

Em perl um objeto é apenas uma estrutura de dados que sabe a qual classe ela pertence. Uma classe é simplesmente um pacote/package. A classe disponibiliza métodos que operam nos objetos. Um método é uma subrotina que aceita a referência de um objeto como primeiro argumento, o $self.

No fundo os objetos são um hash que tem uma 'classe' identificadora diferente do tradicional HASH. Ao invés de HASH, vai aparecer Nome::Modulo.

Todas as classes em perl precisam ser finalizadas com um "1;" no final delas, Segue um exemplo simples de um módulo:

    package Minha::Classe;    #nome da minha classe
    use strict;               
    use warnings;

    # metodo pular
    sub pular {
        my ( $self ) = @_; 
        warn "pular";
    }

    1;  #última linha da classe

Aparentemente este 1 é o último comando executado ao fazer uso com 'use' ou 'require'. Ou seja, o interpretador evalua o código e a última linha é o 1, que retorna verdadeiro, indicando que tudo que veio antes foi evaluado corretamente. Caso o 1 não seja retornado, o interpretador entende que pode ter ocorrido uma falha durante a leitura desse módulo consequentemente resultando em erro.

=head3 Class::Accessor

    $ perldoc Class::Accessor

O Class::Accessor é um excelente módulo para criar classes. Dada uma lista de atributos (passada pra mk_accessors) ele cria todos os accessors da sua classe. Isso facilida bastante pois não há necessidade de criar getters e setters. Só preciso me peocupar com os atributos em si. 

Este módulo era muito utilizado antes do lançamento do Moose e do Moo e Mouse. 

    package Foo;
    use base qw|Class::Accessor|;
    Foo->mk_accessors( qw| nome idade | );

    use  DDP;
    my $f = Foo->new();
    $f->idade( 'dimenor' );     #método para setar o valor do atributo idade.
    warn $f->idade;             #retorna o valor atual do atributo
    warn $f->{_idade};          #variável interna onde o class accessor guarda os valores
    warn p $f;

=head3 Moose

O Moose extende o sistema padrão de objetos do perl. Ao mesmo tempo o Moose junta as melhores e mais atuais boas práticas utilizadas nas mais diversas linguagens de programação. O foco principal do moose é permitir que programadores foquem mais no que precisam fazer e menos na mecânica de relacionamento a objetos. Um exemplo deste tipo de facilidade, são os getters e setters.. normalmente é necessário criar os getters e setters manualmente e isso é repetitivo e tedioso por ser manual, então o Moose permite que seja declarado apenas os atributos e os getters e setters são criados automaticamente. Nesse exemplo o foco se resume à criação de atributos.

O Moose pode ser bem complexo, mas o basicão dele é simples de entender. Além de definir os atributos e métodos, tambem oferece facilidades não encontradas nos sistemas de orientação a objetos encontrados por ai.. por exemplo: suporte a Roles, Traits, modificadores de métodos (before, around, after)

Exemplo de classe com Moose:

primeiro vou criar uma classe pessoa. Toda pessoa tem um nome, e uma idade. E são atributos que guardam valores relacionados à pessoa. Toda pessoa pode falar, então há um método 'falar' na classe pessoa.

    package Pessoa;
    use Moose;

    has nome  => ( is => 'rw' );
    has idade => ( is => 'rw' );

    sub falar {
        my ( $self ) = @_;
        warn "falando.."; 
    }

    1;

agora vou criar uma "Role" chamada Atleta. Rola quer dizer papel, ou seja, é como se fosse um papel a mais que eu posso aplicar em cima de uma outra classe. Por exemplo, se tenho uma classe Pessoa , poderia criar uma Classe Atletas que contempla o conhecimento necessário para atletas. Posteriormente poderia criar uma classe que herda de Pessoa e aplica a Role Atleta, gerando assim uma nova classe de PessoaAtleta, veja o exemplo:

    package Atleta;
    use Moose::Role;

    sub correr {
        my ( $self ) = @_; 
        warn qq{meu nome é $self->{nome} e vou correr};
    }

    1;

e agora vou criar uma classe PessoaAtleta que extende a classe Pessoa. E aplica a role 'Atleta'.

    package PessoaAtleta;
    use Moose;
    extends qw|Pessoa|;
    with qw|Atleta|;

    1;

E este é o uso da minha classe PessoaAtleta:

    use DDP;
    my $f = PessoaAtleta->new();
    $f->nome('Jão');
    $f->idade( 'dimenor' );     #método para setar o valor do atributo idade.
    warn $f->idade;             #retorna o valor atual do atributo
    warn $f->correr;
    warn p $f;

Outra facilidade do moose, é poder passar os atributos a serem populados já no método new. Tambem é possível passar um objeto hash.

    my $p2 = PessoaAtleta->new(
        nome    => 'Jão',
        idade   => 'dimenor'
    );
    warn $p2->correr;
    warn $p2->nome;
    warn p $p2;

=head3 Moo

O Moo veio após o Moose principalmente pois algumas pessoas queriam melhorar o desempenho do Moose, no entanto algumas funcionalidades essenciais do moose (dependendo do uso) influenciam no tempo de inicialização do objeto. Para a maioria dos projetos, esse tempo é irrelevante, mas em projetos onde microsegundos fazem a diferença entre lucro ou prejuízo pressionou para a criação de algo similar ao Moose mas sem todas as funcionalidades e que fosse muito mais rápido.

O Moo tem o básico do Moose e é compatível com Moose. Então é possível criar uma classe Pessoa, Atleta e PessoaAtleta da segunte maneira com Moo:

    package Pessoa;
    use Moo;

    has nome  => ( is => 'rw' );
    has idade => ( is => 'rw' );

    sub falar {
        my ( $self ) = @_;
        warn "falando.."; 
    }

    1;

    package Atleta;
    use Moo::Role;

    sub correr {
        my ( $self ) = @_; 
        warn qq{meu nome é $self->{nome} e vou correr};
    }

    1;

    package PessoaAtleta;
    use Moo;
    extends qw|Pessoa|;
    with qw|Atleta|;

    1;

    use DDP;
    my $f = PessoaAtleta->new();
    $f->nome('Jão');
    $f->idade( 'dimenor' );     #método para setar o valor do atributo idade.
    warn $f->idade;             #retorna o valor atual do atributo
    warn $f->correr;
    warn p $f;

    my $p2 = PessoaAtleta->new(
        nome    => 'Jão',
        idade   => 'dimenor'
    );
    warn $p2->correr;
    warn $p2->nome;
    warn p $p2;

=head2 Map e Grep

map e grep são dois comandinhos que rodam em cima de uma lista. Tambem podem retornar uma lista com o resultado das operações. Usados em conjunto podem ser bastante poderosos para resolver problemas comuns.

=head3 map

A função map funciona como um foreach. É como se fosse um foreach $_ ( @items ) { ...faz algo com $_ e joga na lista de retorno, que pode ser usada opcionalmente ... } .

O map trabalha em cima de cada item de uma lista. Isto é, pode fazer qualquer coisa com cada item de uma lista e pode retornar uma lista com o resultado de execução sob cada item da lista de entrada.

    my @lista = ( qw| 4 2 5 6 2 3| );
    my @lista_times_2 = map {
        $_ * 2
    } @lista;
    use DDP; warn p @lista_times_2;

não precisa necessariamente retornar uma lista, o map pode ser usado e seu retorno não precisa ser atribuído a nada, por exemplo:

    my @lista = ( qw| 4 2 5 6 2 3| );
    my @outra_lista = ();
    map {
        push @outra_lista, $_ if $_ > 3   # se o item for maior que 3 vai inserir em @outra_lista
    } @lista;
    use DDP; warn p @outra_lista;

=head3 grep

O grep funciona como um filtro e retorna os itens que passam o filtro. Ou seja, se eu tenho uma lista e preciso saber quais items atendem a determinados critérios, posso filtrá-los conforme o exemplo:

    my @lista = ( qw| 5 21 2 5 6 77 3 3 54 2| );
    my @menores_q_6 = grep { $_ < 6 } @lista;
    use DDP ; warn p @menores_q_6;

Então o que dá pra perceber é que map trabalha em cima de uma lista, e pode retornar uma lista.  Grep tambem, trabalha em cima de uma lista e pode retornar uma lista. Isso quer dizer que os comandos são compatíveis para serem usados em conjunto, pois dada uma lista, o map pode ser usado junto com um grep que retorna uma lista e passa para o map executar em seguida. Veja o exemplo, muito bom que foi publicado na internet em http://www.pal-blog.de/entwicklung/perl/perl-map-und.html?utm_source=pal-blog&utm_medium=RSS&utm_campaign=RSS: 

Suponha que você tem uma lista de números, e precisa saber quais são menores que dez, e multiplicar esses itens por 2.

A solução mais comum e genérica com encaixe em qualquer linguagem é:

    my @a = (10,1,3,42,5,2,666,9);
    my @b;
    for my $item (@a) { # Alle Elemente von @a durchgehen
       if ($item < 10) { # Nur Werte kleiner als 10 bearbeiten
          push @b, $item * 2; # Wert verdoppeln und an @b anhängen
       }
    }

Uma outra possível solução mais voltada à linguagem perl, envolveria o uso de map e grep.


    my @a = (10,1,3,42,5,2,666,9); # lista de itens
    my @temp = grep { $_ < 10 } @a; # filtra os itens menores que dez e joga em @temp
    my @b = map { $_ * 2 } @temp; # pra cada item em temp, executa item * 2 e joga em @b



No comando anterior, grep vem antes de map. E cada um está separado, cada um em sua linha, Eles podem trabalhar em conjunto pois ambos precisam de uma lista como input, e ambos tem uma lista como output. Ou seja, é possivel usar eles em uma única linha, ex:

    my @a = (10,1,3,42,5,2,666,9);
    my @b = map { $_ * 2 } grep { $_ < 10 } @a;


e outra opção seria executar o filtro sem grep e apenas dentro do map:

    my @a = (10,1,3,42,5,2,666,9);
    my @b = map { if ($_ < 10) { $_ * 2 } else { () } } @a;

=head4 Itens vazios na lista de retorno

As vezes é preciso jogar vazio na lista de retorno. A primeira intenção é jogar um undefined. Mas como é uma lista, a maneira correta é atribuir um item de lista vazia, que resulta em nada.

    my @lista               = ( qw| joao amanda leticia jessica jenifer jorge roberto | );
    my @terminando_em_a     = map {  if ( $_ =~ m!a$! ) { $_ } else { () } } @lista;
    warn p @terminando_em_a;

=head2 Conexão com banco de dados

=head2 Referências

  perldoc
  perl.org

=head2 APÊNDICE

=head3 TEMA LIVRE

Esta seção é destinada a pessoas interessadas em colaborar com soluções pontuais que sirvam como referência a outros usuários.
Deixo alguns exemplos de soluções pontuais que me interessaria conhecer.

=head4 manipulando arquivos excel com perl

#TODO..

=head4 acessar páginas de internet com perl

#TODO..

=head2 AUTHOR

Hernan Lopes

=head2 OUTROS CONTRIBUIDORES

Se você ajudou a melhorar este documento, insira seu nome abaixo:

=cut


1;
